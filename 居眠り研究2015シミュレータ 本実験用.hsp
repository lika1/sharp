#include "hgimg3.as"	;３Ｄを使いたいとき、ＨＳＰ拡張プラグインのヘッダーファイルが必要
#include "mod_joystick.as"

	randomize								;乱数の初期化
	onexit	*exit							;プログラム終了時の割り込み処理（終了処理：× ボタンを押すと「指定ラベル」に飛ぶ）
	
	setting_data = ""
	notesel setting_data					;設定情報を保存するメモリノートパッド命令のバッファ名
	noteload "setting_new_data.txt"			;「setting_data」という変数に「setting_new_data.txt」の中身をロードする
	
*re_set
	ddim set_data,12						;テキストから抜き出したデータを一時的に保管したりする変数を定義
	repeat									;（始）テキストデータから設定情報を取り出すループ（始）
		noteget set_data(cnt), cnt			;1行ずつデータを取り出し，一時的に保管する為の変数 set_dataに代入
		if(set_data(cnt) = "") : break		;データが終わったらループを抜け出す
	loop									;（終）テキストデータから設定情報を取り出すループ（終）
	
	;テキストから読み取った内容をそれぞれ変数に格納する
	win_xsize       = int(set_data(0))		;画面サイズ（x）
	win_ysize       = int(set_data(1))		;画面サイズ（y）
	lead_car_speed1 = set_data(2)			;先行車の速度（最低速度）
	lead_car_speed2 = set_data(3)			;先行車の速度（最高速度）
	change_speed    = set_data(4)			;先行車の速度変化の段階数
	adjust_range    = set_data(5)			;先行車の速度調整間隔時間
	limit_min_range = set_data(6)			;先行車との挙動限界距離（最短）
	limit_max_range = set_data(7)			;先行車との挙動限界距離（最長）
	min_range       = set_data(8)			;先行車との適正距離（最短）
	max_range       = set_data(9)			;先行車との適正距離（最長）
	left_car_speed  = set_data(10)			;左車線を走行している車の時速
	right_car_speed = set_data(11)			;右車線を走行している車の時速
	
	screen 0,(win_xsize),(win_ysize),0,0,0  					;フロント画面の作成
	if(win_xsize = 800)&&(win_ysize = 600)   : win_size = 0		;画面の規定サイズ１
	if(win_xsize = 1024)&&(win_ysize = 768)  : win_size = 1		;画面の規定サイズ２
	if(win_xsize = 1280)&&(win_ysize = 720)  : win_size = 2		;画面の規定サイズ３
	if(win_xsize = 1280)&&(win_ysize = 768)  : win_size = 3		;画面の規定サイズ４
	if(win_xsize = 1360)&&(win_ysize = 768)  : win_size = 4		;画面の規定サイズ５
	if(win_xsize = 1366)&&(win_ysize = 768)  : win_size = 5		;画面の規定サイズ６
	if(win_xsize = 1400)&&(win_ysize = 1050) : win_size = 6		;画面の規定サイズ７
	if(win_xsize = 1920)&&(win_ysize = 1080) : win_size = 7		;画面の規定サイズ８
	win_size2 = win_size
	color : boxf
	button goto "デフォルト", *default_set;0
	
	objmode 2, 1 									;この命令によりオブジェクト内のフォント調整がfont命令で，できるようなる

	font_size = int(double(win_ysize) * 0.04558)	;フォントサイズを画面の大きさから設定
	color 255,255,255 : font msgothic,font_size
	;画面サイズ（ウインドウサイズに合わせて位置，大きさを自動調整）
	pos (font_size),(1.5 * font_size)      : mes "画面サイズ"
	objsize (double(win_xsize)*0.25),(double(win_ysize)*0.05),100		;オブジェクトサイズ変更
	pos (font_size * 13),(1.5 * font_size) : combox win_size,100,"800×600\n1024×768\n1280×720\n1280×768\n1360×768\n1366×768\n1400×1050\n1920×1050";①
	;先行車の速度幅（km/h ～ km/h）
	pos (font_size),(3.5 * font_size)      : mes "先行車の速度幅"
	pos (font_size * 13),(3.5 * font_size) : input lead_car_speed1,(font_size * 2),(font_size),3;②
	pos (font_size * 15),(3.5 * font_size) : mes " km/h～"
	pos (font_size * 19),(3.5 * font_size) : input lead_car_speed2,(font_size * 2),(font_size),3;③
	pos (font_size * 21),(3.5 * font_size) : mes " km/h"
	;先行車の速度変化段階数（段階）
	pos (font_size),(5.5 * font_size)      : mes "先行車の速度変化段階数"
	pos (font_size * 14),(5.5 * font_size) : input change_speed,(font_size),(font_size),2;④
	pos (font_size * 15),(5.5 * font_size) : mes " 段階"
	;先行車の速度調整間隔（秒）
	pos (font_size),(7.5 * font_size)      : mes "先行車の速度調整間隔"
	pos (font_size * 14),(7.5 * font_size) : input adjust_range,(2 * font_size),(font_size),3;⑤
	pos (font_size * 16),(7.5 * font_size) : mes " 秒"
	;先行車の挙動範囲（ｍ）
	pos (font_size),(9.5 * font_size)      : mes "先行車の挙動範囲"
	pos (font_size * 13),(9.5 * font_size) : input limit_min_range,(font_size * 3),(font_size),4;⑥
	pos (font_size * 16),(9.5 * font_size) : mes " m～"
	pos (font_size * 19),(9.5 * font_size) : input limit_max_range,(font_size * 3),(font_size),4 ;⑦
	pos (font_size * 22),(9.5 * font_size) : mes " m"
	;先行車との適正距離（ｍ）
	pos (font_size),(11.5 * font_size)      : mes "追従作業の適正距離"
	pos (font_size * 13),(11.5 * font_size) : input min_range,(font_size * 3),(font_size),4;⑧
	pos (font_size * 16),(11.5 * font_size) : mes " m～"
	pos (font_size * 19),(11.5 * font_size) : input max_range,(font_size * 3),(font_size),4 ;⑨
	pos (font_size * 22),(11.5 * font_size) : mes " m"
	;左車線の車の時速（㎞/h）
	pos (font_size),(13.5 * font_size)      : mes "左車線の車の速度"
	pos (font_size * 13),(13.5 * font_size) : input left_car_speed,(font_size * 2),(font_size),3;⑩
	pos (font_size * 15),(13.5 * font_size) : mes " km/h"
	;右車線の車の時速（㎞/h）
	pos (font_size),(15.5 * font_size) : mes "右車線の車の速度"
	pos (font_size * 13),(15.5 * font_size) : input right_car_speed,(font_size * 2),(font_size),3;⑪
	pos (font_size * 15),(15.5 * font_size) : mes " km/h"
	;ボタンの設置
	objsize (double(win_xsize)*0.25),(double(win_ysize)*0.08),100					;オブジェクトサイズ変更
	pos (double(win_xsize)*0.05),(win_ysize - font_size*4)  : button goto "デフォルト", *default_set;⑫
	pos (double(win_xsize)*0.375),(win_ysize - font_size*4) : button goto "設定を保存", *save_set_data;⑬
	pos (double(win_xsize)*0.7),(win_ysize - font_size*4) : button goto "実験開始", *start_ex;⑭
	
	button_flag = 0
	objenable 13,0
*set_up
	if(win_size ! win_size2){
		switch win_size
		case 0
			win_xsize = 800 : win_ysize = 600 : win_size2 = 0
			swbreak
		case 1
			win_xsize = 1024 : win_ysize = 768 : win_size2 = 1
			swbreak
		case 2
			win_xsize = 1280 : win_ysize = 720 : win_size2 = 2
			swbreak
		case 3
			win_xsize = 1280 : win_ysize = 768 : win_size2 = 3
			swbreak
		case 4
			win_xsize = 1360 : win_ysize = 768 : win_size2 = 4
			swbreak
		case 5
			win_xsize = 1366 : win_ysize = 768 : win_size2 = 5
			swbreak
		case 6
			win_xsize = 1400 : win_ysize = 1050 : win_size2 = 6
			swbreak
		case 7
			win_xsize = 1920 : win_ysize = 1080 : : win_size2 = 7
			swbreak
		swend
	}
	
	if(win_xsize = set_data(0))&&(flag = 0)         : button_flag = 0
	if(win_ysize = set_data(1))&&(flag = 1)         : button_flag = 0
	if(lead_car_speed1 = set_data(2))&&(flag = 2)   : button_flag = 0
	if(lead_car_speed2 = set_data(3))&&(flag = 3)   : button_flag = 0
	if(change_speed = set_data(4))&&(flag = 4)      : button_flag = 0
	if(adjust_range = set_data(5))&&(flag = 5)      : button_flag = 0
	if(limit_min_range = set_data(6))&&(flag = 6)   : button_flag = 0
	if(limit_max_range = set_data(7))&&(flag = 7)   : button_flag = 0
	if(min_range = set_data(8))&&(flag = 8)         : button_flag = 0
	if(max_range = set_data(9))&&(flag = 9)         : button_flag = 0
	if(left_car_speed = set_data(10))&&(flag = 10)  : button_flag = 0
	if(right_car_speed = set_data(11))&&(flag = 11) : button_flag = 0
	
	if(button_flag = 0){
		objenable 13,0 : objenable 14,1
		if(win_xsize ! set_data(0))        : button_flag = 1 : flag = 0
		if(win_ysize ! set_data(1))        : button_flag = 1 : flag = 1
		if(lead_car_speed1 ! set_data(2))  : button_flag = 1 : flag = 2
		if(lead_car_speed2 ! set_data(3))  : button_flag = 1 : flag = 3
		if(change_speed ! set_data(4))     : button_flag = 1 : flag = 4
		if(adjust_range ! set_data(5))     : button_flag = 1 : flag = 5
		if(limit_min_range ! set_data(6))  : button_flag = 1 : flag = 6
		if(limit_max_range ! set_data(7))  : button_flag = 1 : flag = 7
		if(min_range ! set_data(8)) 	   : button_flag = 1 : flag = 8
		if(max_range ! set_data(9))	       : button_flag = 1 : flag = 9
		if(left_car_speed ! set_data(10))  : button_flag = 1 : flag = 10
		if(right_car_speed ! set_data(11)) : button_flag = 1 : flag = 11
	}
	if(button_flag =1) : objenable 13,1 : objenable 14,0
	
	wait 2
	goto *set_up

*default_set
	setting_data = ""
	notesel setting_data					;設定情報を保存するメモリノートパッド命令のバッファ名
	noteload "default.txt"					;「setting_data」という変数に「setting_new_data.txt」の中身をロードする
	notesave "setting_new_data.txt"
	goto *re_set
	
*save_set_data
	sdim set_data2,12	
	;配列に新しい設定情報を格納(保存するとき文字列にしないと実数と整数の違いによりエラーが出る）
	set_data2(0)  = str(win_xsize)			;画面サイズ（x）
	set_data2(1)  = str(win_ysize)			;画面サイズ（y）
	set_data2(2)  = str(lead_car_speed1)	;先行車の速度（最低速度）
	set_data2(3)  = str(lead_car_speed2)	;先行車の速度（最高速度）
	set_data2(4)  = str(change_speed)		;先行車の速度変化の段階数
	set_data2(5)  = str(adjust_range)		;先行車の速度変化の段階数
	set_data2(6)  = str(limit_min_range)	;先行車との適正距離（最短）
	set_data2(7)  = str(limit_max_range)	;先行車との適正距離（最長）
	set_data2(8)  = str(min_range)			;先行車との適正距離（最短）
	set_data2(9)  = str(max_range)			;先行車との適正距離（最長）
	set_data2(10) = str(left_car_speed)		;左車線を走行している車の時速
	set_data2(11) = str(right_car_speed)	;右車線を走行している車の時速
	
	setting_data = ""
	notesel setting_data
	;テキストに新しい設定を上書きする
	repeat 12								;（始）テキストデータから設定情報を取り出すループ（始）
		noteadd set_data2(cnt), cnt, 1
		notesave "setting_new_data.txt"
	loop
	goto *re_set
	
*start_ex
	clrobj					;前半部のボタンやインプットボックスなどを消去
	color : boxf			;画面全体を黒く塗りつぶして，上部で書かれた文字を消去
	font msgothic,int(0.0652 * win_ysize)
	pos (win_xsize/2 - int(0.163 * win_xsize)),(win_ysize/2 - int(0.0326 * win_ysize)) : color 255,255,255 : print "NOW LODING"
	
//--------あらかじめ定義して処理を軽くする--------------------------------------
	;----変数の宣言---------------------
	;配列
	dim ROAD,3											;道路
    dim HODOU_LEFT,20									;左側　歩道
    dim HODOU_RIGHT,20									;右側　歩道
    dim TREE_LEFT,50									;左側　木
	dim TREE_RIGHT,50									;右側　木

	notesel save_data									;サンプリングデータ保存用
	#const sampling  1000								;データ記録のサンプリング時間
	
	;追従作業のフィードバック
	BLUE_FRAME_OFFSET_X	 = win_xsize/2								;画面中心からのオフセット　X
	BLUE_FRAME_OFFSET_Y	 = win_ysize/2								;画面中心からのオフセット　Y
	BLUE_FRAME_WIDTH	 = int(0.0977*win_xsize)					;横の長さ
	BLUE_FRAME_HEIGHT	 = int(0.0912*win_ysize)					;縦の長さ
	BLUE_FRAME_THICKNESS = int(0.0153*win_xsize*win_xsize/1000)		;線の太さ

	SHAKAN_MIN = double(min_range)/0.165							;枠から出たとみなす距離
	SHAKAN_MAX = double(max_range)/0.165							;枠から出たとみなす距離
	LIM_SHAKAN_MIN = double(limit_min_range)/0.165					;枠から出たとみなす距離
	LIM_SHAKAN_MAX = double(limit_max_range)/0.165					;枠から出たとみなす距離
	
	BLUE_FRAME_CENTER_X	=	BLUE_FRAME_OFFSET_X ;+ (ginfo_sizex/2)
	BLUE_FRAME_CENTER_Y	=	BLUE_FRAME_OFFSET_Y ;+ (ginfo_sizey/2)
	
	;カウントダウン番号，眠気評価の画像の大きさ・座標用変数
	sign_xsize = int(0.3868 * win_xsize)			;画像の大きさ(X座標）
	sign_ysize = int(0.3529 * win_ysize)			;画像の大きさ(Y座標）
	sign_xpos  = win_xsize/2						;画像の座標(X座標）
	sign_ypos  = int(0.326 * win_ysize)				;画像の座標(Y座標）
	;眠気評価用の大きさ・座標用変数
	nemuke_xsize = int(0.625 * win_xsize)			;画像の大きさ(X座標）
	nemuke_ysize = int(0.625 * win_ysize)			;画像の大きさ(Y座標）
	nemuke_xpos  = int(0.323 * win_xsize)			;画像の座標(X座標）
	nemuke_ypos  = int(0.469 * win_ysize)			;画像の座標(Y座標）
	
	;左車線・右車線の自動車の速度用変数
	L_CAR_S = 0.2777778 * double(left_car_speed) * 0.015 * 6.0		;左車線を走行してる車の移動量
	R_CAR_S = 0.2777778 * double(right_car_speed) * 0.015 * 6.0		;右車線を走行してる車の移動量
	
	kyori = 0.0 : kyori1 = 0.0 : kyori2 = 0.0 : jisoku2 = 0.0		;時速計算用変数
	aida = 0.0
	
	steering_ang = 33089		;ハンドルをまっすぐにした状態の値
	hs = 0.000000200			;ハンドルの曲がり具合
	
	sokudo = -3.5				;3.5 --> 約77.4 km/h
	speed = 0.0 : car_speed = 0.0 : max_speed = 0.0
	cnt_n = 0 
	st_ex = 0
	time_m = 0.0 : time_s = 0.0
	time_set = 0.0
	;
	camera_pos_x == 0 : camera_pos_y == 0 : camera_pos_z == 0	;カメラの位置
	camera_ang_x == 0 : camera_ang_y == 0 : camera_ang_z == 0	;カメラの向き　　
																;
	road_loop　== 0 : road_loop2  == 0							;背景のループ用
	hodou_loop == 0 : hodou_loop2 == 0							;
	tree_loop  == 0 : tree_loop2  == 0							;
	frame = 0

//--------３Ｄモデル(背景)の準備------------------------------------------------
	hgini ;プラグインの初期化（現在のウインドウでHGIMG3を初期化）
	
	;----テクスチャフォント-------------
	setfont 16,16,12,1		;オリジナルフォント定義
	texload "fontchr.bmp"																;フォントテクスチャの登録

	;----眠気評価指示の表示-------------
	setuv 0,0,640,480						;※setuvでは流用する画像の大きさを入れるのが普通
	texload "文字.bmp"           : moji = stat				;眠気評価指示表示用画像
	texload "眠気　正常.bmp"     : kakusei = stat			;「正常」という文字画像
	texload "眠気　少し眠い.bmp" : sukosinemui = stat		;「少し眠い」という文字画像
	texload "眠気　眠い.bmp"     : kanarinemui = stat		;「眠い」という文字画像
	
	;----カウントダウン用画像-----------
	setuv 0,0,264,181
	texload "go.bmp"	 : ready_go = stat					;Go!
	texload "1time.bmp"  : sec_ago1  = stat					;①
	texload "2time.bmp"  : sec_ago2  = stat					;②
	texload "3time.bmp"  : sec_ago3  = stat					;③
	texload "15time.bmp" : sec_ago15 = stat					;⑩
	
	;----背景のモデル-------------------
	;----空----
	clscolor $AFBFFC				;背景色の設定
	addxfile sky_model,"skybox.x"	;空のモデルの読み込み
	modelshade sky_model,0			;モデルのシェーディングモードの設定
	regobj SKY,sky_model			;空の登録
	setscale SKY, 30, 30, 30		;空の大きさの設定
	setpos SKY, 0, 10, 0			;空の位置の設定
	setefx SKY,$500					;Zバッファを更新しない
	objproj SKY,1					;オブジェクトのプロジェクション変更　通常のZクリップを無効にする

	;----道路の準備----(道路は３つのタイルをループさせている→０後方，１足元，２前方）
	addmesh road_model,1, 12.56, 16, 90, 1520	;道路の設定
	texload2 "road2(3line)_onew.bmp"			;道路のテクスチャの読み込み
	regobj ROAD.0,road_model,OBJ_GROUND			;道路の登録
	regobj ROAD.1,road_model,OBJ_GROUND			;
	regobj ROAD.2,road_model,OBJ_GROUND			;
	setpos ROAD.0, 0, 0.2, -38*40				;道路の位置の設定
	setpos ROAD.1, 0, 0.2, 0					;
	setpos ROAD.2, 0, 0.2, 38*40				;

	;----歩道の準備----
	addxfile hodou_model,"hodou.x"							;歩道のモデルの読み込み													;
	repeat 20												;左側20個　右側20個 歩道のオブジェクトを作る
		;右側の歩道											;
		regobj   HODOU_RIGHT(19-cnt),hodou_model,OBJ_STATIC	;
		setpos   HODOU_RIGHT(19-cnt), 55, 0, 70*(9-cnt)		;
		setang   HODOU_RIGHT(19-cnt),  0, M_PI, 0			;
    	setscale HODOU_RIGHT(19-cnt), 12, 12, 25			;
		;左の歩道											;
		regobj   HODOU_LEFT(19-cnt),HODOU_model,OBJ_STATIC	;
		setpos   HODOU_LEFT(19-cnt),-55, 0, 70*(9-cnt)		;
		setang   HODOU_LEFT(19-cnt),  0, 0, 0				;
    	setscale HODOU_LEFT(19-cnt), 12, 12, 25				;
    loop													;

	;----木の準備----	
	texload2 "tree.tga"																;木のテクスチャの登録
	addplate tree_model,1,15,30,0,0,255,255,stat									;木の登録
																					;
	repeat 50
		;右側50個
		regobj TREE_RIGHT(49-cnt), tree_model, OBJ_STATIC|OBJ_TREE|OBJ_LATE			;
		setpos TREE_RIGHT(49-cnt), 47+0.01*rnd(20), -14.5, 25*(24-cnt)+0.01*rnd(10)	;木の位置　x座標，y座標，z座標 47の理由＝x座標47.5の時折り返し
		;左側50個																	;
		regobj TREE_LEFT(49-cnt),  tree_model, OBJ_STATIC|OBJ_TREE|OBJ_LATE			;
		setpos TREE_LEFT(49-cnt), -47-0.01*rnd(20), -14.5, 25*(24-cnt)+0.01*rnd(10)	;木の位置　x座標，y座標，z座標 -47の理由＝x座標-47.5の時折り返し
	loop																			;
	
	//--------車両の読み込み--------------------------------------------
	
	;----先行車両----------------------
    addxfile car_model1,"evo8-silver.x"				;先行車両のモデルの読み込み
    regobj Leading_CAR,car_model1,OBJ_MOVE			;先行車両の登録
    setpos Leading_CAR, 0, 0, 310					;先行車両の初期位置の設定
    setang Leading_CAR, 0, M_PI, 0					;先行車両の向きの設定
    setscale Leading_CAR, 5.5, 5.5, 5.5				;先行車両の大きさ

	;----他の車-----------------------
	addxfile car_model2,"evo8-red.x"				;追い越し車線走行車両のモデルの読み込み
	if stat < 0 : title "失敗"
	addxfile car_model3,"evo8-black.x"				;走行車線走行車両のモデルの読み込み
	if stat < 0 : title "失敗"
	;車両A－右車線
	regobj R_CAR,car_model2,OBJ_STATIC				;追い越し車線走行車両の登録
	setpos R_CAR, -22, 0, 0							;追い越し車線走行車両の初期位置の設定
 	setang R_CAR, 0, M_PI, 0						;追い越し車線走行車両の向きの設定
	setscale R_CAR, 5.5, 5.5, 5.5					;追い越し車線走行車両の大きさの設定
	;車両B－左車線
	regobj L_CAR,car_model3,OBJ_STATIC				;走行車線走行車両の登録
	setpos L_CAR, 22, 0, 0							;走行車線走行車両の初期位置の設定
 	setang L_CAR, 0, M_PI, 0						;走行車線走行車両の向きの設定
	setscale L_CAR, 5.5, 5.5, 5.5					;走行車線走行車両の大きさの設定
	
	;---矢印（自車）-------------------------------------------------------------------------
	setuv 0,0,63,92                    	;矢印の画像を読み込む位置
	addplate yajirushi_model,1,5,35    	;矢印の大きさ ID,モード,横,縦
	texload "矢印3.bmp"
	regobj player,yajirushi_model
	setang player,-M_PI/2,M_PI,0		;矢印の向き???

    cammode CAM_MODE_AUTOMOVE,player
    setwork HGOBJ_CAMERA, 35, M_PI, -5	;カメラの視点,前後,周囲,高さ
    setdir HGOBJ_CAMERA,0,-8,0			;セット位置（角度）？横,高さ,前後

	;----ライトの準備--------------------
	setang HGOBJ_LIGHT,4.9,M_PI,0		;ライトの向きの設定
    setscale HGOBJ_LIGHT,150,150,150	;ライトの色の設定
	setdir HGOBJ_LIGHT,50,50,50			;ライトのアンビエント色の設定

//--------Enterを押したら実験開始-----------------------------------------------
	repeat
		hgdraw
	
		hggettime time,0			;hgini命令を通過してからの経過時間を 1ms 単位で取得	 ※ただし、上限は100000 msまで,それを超えると0 msから数え直す
		hggettime count,1			;上限である100000 msを超えた回数の取得
		time = count*100000+time	;現在の経過時間の算出
			
		getkey enter,13	
		if enter=1: hgsync 5 : push_time=time : break
		hgsync 5	;時間待ち（処理が速くなり過ぎないように）

	loop

;-----------------------------------------------------------------------------------------
*main	
	kyori1 = camera_pos_z 
	
	getpos player,camera_pos_x,camera_pos_y,camera_pos_z	;カメラの位置(座標)を取得
	getang player,camera_ang_x,camera_ang_y,camera_ang_z	;カメラの角度を取得

	kyori2 = camera_pos_z

	;--------サブルーチンジャンプ---------------------------------------------------------------------------------
	gosub *camera_control	;カメラ操作
	gosub *background		;背景のループ
	gosub *nemukehyouka
	gosub *alldraw			;描画

	//時速計算 
	jisoku2 = -(39.996 * speed +0.1324)				;speedの値から時速を算出※ただしPCの処理能力により変わる恐れアリ
	if jisoku2<=0 : jisoku2=0						;speedが0だとマイナスになるので修正

	if data.8 = 512 : goto *exit					;ハンドルのレバーを倒すと終了

	kyori = kyori + speed*cos(camera_ang_y)

	aida = kyori2 - kyori1
	
	title "経過時間 = "+elasped_time+" (s)    speed : "+ speed +"  brake_on : "+ brake_on+"   jisoku: "+ aida*0.166/0.015*3.6
	
	if (st_ex = 1)&&(time - start_time - s_time*sampling) >= 0 : gosub *abc	;データ保存用サンプリング時間
	
	camera_pos_z2 = camera_pos_z	;現在のcamera_pos_zと、次のcamera_pos_zを比べるためにcamera_pos_z2に内容を保存	
	
	jiko =" "	
	
	if (CAR_pos_z-camera_pos_z)<=0	&	(-10 <= camera_pos_x & camera_pos_x <= 10)	:jiko ="先行車"
	;goto *exit			;車間距離0座標以下	;強制終了

goto *main


/*******************************************************************************
-------以下、goto/gosub命令によるジャンプ先ラベル-------------------------------
*******************************************************************************/
	
//--------操作------------------------------------------------------------------
*camera_control
	//キーボードで操作
	stick key,15	;操作キーの設定（押しっぱなしでも検出）
	if 1=key : addang player,0.0,0.008,0.00		;カメラの左旋回
	if 4=key : addang player,0.0,-0.008,0.0		;カメラの右旋回
	
	if(2=key)&(speed<29050) : speed = speed -0.006615		;カメラの加速
	if 8=key : speed = speed + 0.00926154					;カメラの減速
	//ジョイスティック（ハンドル）で操作
	joyGetPosEx data,0	;ハンドル（ゲームパット）の設定
	jyoutai = stat			;ステアリングとPCが接続されていたら「0」が入る
	;☆★☆★☆★☆ステアリング型コントローラによるハンドル操作☆★☆★☆★☆
	if jyoutai=0 : addang player, 0.0, hs*(steering_ang-double(data.2)), 0.0 
	
	;----ペダル型コントローラによる操作----
	pedal = " "		;ブレーキの判定
	pedal_per = 0.0
	if (data.3 < 32511) : pedal = "アクセル" : pedal_per = (32511 - data.3)*100/32511		;ペダルの状態＆ペダルの踏み込み具合(アクセル）
	if (data.3 > 32511) : pedal = "ブレーキ" : pedal_per = (data.3)*100/32767 - 100			;ペダルの状態＆ペダルの踏み込み具合（ブレーキ）
	
	;----操作による位置情報への反映----
	;アクセルの踏み込み量に合わせて最大速度を調整
	if (31427 <= data.3)&&(data.3 < 32511) : max_speed = -0.1257269		; 0  ～ 5km
	if (30344 <= data.3)&&(data.3 < 31427) : max_speed = -0.2514538		; 5  ～ 10km
	if (29260 <= data.3)&&(data.3 < 30344) : max_speed = -0.3771807		;10  ～ 15km
	if (28176 <= data.3)&&(data.3 < 29260) : max_speed = -0.5029076		;15  ～ 20km
	if (27093 <= data.3)&&(data.3 < 28176) : max_speed = -0.6286345		;20  ～ 25km
	if (26009 <= data.3)&&(data.3 < 27093) : max_speed = -0.7543614		;25  ～ 30km
	if (24925 <= data.3)&&(data.3 < 26009) : max_speed = -0.8800883		;30  ～ 35km
	if (23841 <= data.3)&&(data.3 < 24925) : max_speed = -1.0058152		;35  ～ 40km
	if (22758 <= data.3)&&(data.3 < 23841) : max_speed = -1.1315421		;40  ～ 45km
	if (21674 <= data.3)&&(data.3 < 22758) : max_speed = -1.257269		;45  ～ 50km
	if (20590 <= data.3)&&(data.3 < 21674) : max_speed = -1.3829959		;50  ～ 55km
	if (19507 <= data.3)&&(data.3 < 20590) : max_speed = -1.5087228		;55  ～ 60km
	if (18423 <= data.3)&&(data.3 < 19507) : max_speed = -1.6344497		;60  ～ 65km
	if (17339 <= data.3)&&(data.3 < 18423) : max_speed = -1.7601766		;65  ～ 70km
	if (16256 <= data.3)&&(data.3 < 17339) : max_speed = -1.8859035		;70  ～ 75km
	if (15172 <= data.3)&&(data.3 < 16256) : max_speed = -2.0116304		;75  ～ 80km
	if (14088 <= data.3)&&(data.3 < 15172) : max_speed = -2.1373573		;80  ～ 85km
	if (13004 <= data.3)&&(data.3 < 14088) : max_speed = -2.2630842		;85  ～ 90km
	if (11921 <= data.3)&&(data.3 < 13004) : max_speed = -2.3888111		;90  ～ 95km
	if (10837 <= data.3)&&(data.3 < 11921) : max_speed = -2.514538		;95  ～ 100km
	if ( 9753 <= data.3)&&(data.3 < 10837) : max_speed = -2.6402649		;100 ～ 105km
	if ( 8670 <= data.3)&&(data.3 <  9753) : max_speed = -2.7659918		;105 ～ 110km
	if ( 7586 <= data.3)&&(data.3 <  8670) : max_speed = -2.8917187		;110 ～ 115km
	if ( 6502 <= data.3)&&(data.3 <  7586) : max_speed = -3.0174456		;115 ～ 120km
	if ( 5419 <= data.3)&&(data.3 <  6502) : max_speed = -3.1431725		;120 ～ 125km
	if ( 4335 <= data.3)&&(data.3 <  5419) : max_speed = -3.2688994		;125 ～ 130km
	if ( 3251 <= data.3)&&(data.3 <  4335) : max_speed = -3.3946263		;130 ～ 135km
	if ( 2167 <= data.3)&&(data.3 <  3251) : max_speed = -3.5203532		;135 ～ 140km
	if ( 1084 <= data.3)&&(data.3 <  2167) : max_speed = -3.6460801		;140 ～ 145km
	if (    0 <= data.3)&&(data.3 <  1084) : max_speed = -3.771807		;145 ～ 150km

	;アクセルの踏みこみ量により１フレームでの移動距離を調整
	if (data.3 < 32511)&&(jyoutai=0) {
		if(max_speed < speed){
			if(speed < 0) : speed = speed - 6.0 * 0.002205 * (double(32511 - data.3)/65022.00)
			if(speed = 0) : speed = - (0.000551 * 6.0)
		}
		;アクセルを緩めた時の減速処理
		if(max_speed > speed) : speed = speed + 0.00926154 * 0.2
	}
	
	;エンジンブレーキ（アクセルから足を離したときの処理）
	if(data.3 = 32511) : speed = speed + 0.00926154 * 0.4

	;ブレーキを踏んだ時の処理
	if (data.3 > 32511)&&(jyoutai=0) : speed = speed + 6.0 * 0.00308718 * (double(data.3 - 32511)/65022.00)
	
	if(speed>0) : speed=0.0
	addpos player,double(speed*sin(camera_ang_y)),0.0,double(speed*cos(camera_ang_y))
	
	
	;-----------壁にぶつかった場合に強制的に道路に戻す-----------

	if (camera_pos_x>=47.5){
		jiko="左縁石"
	}
	
		if (camera_pos_x>47.5){
			setpos player,47.5,0,camera_pos_z
			setang player,-M_PI/2,M_PI,0	

		}
	
	if (camera_pos_x<=-47.5){
		jiko="右縁石"
	}
	
		if (camera_pos_x<-47.5){
			setpos player,-47.5,0,camera_pos_z
			setang player,-M_PI/2,M_PI,0
	
		}
		

return


//--------背景のループ----------------------------------------------------------
*background
	;----空のループ----
	setpos SKY,camera_pos_x,10,camera_pos_z		;カメラの現在位置を中心に、位置を移動させる

	;----道路のループ----
	road_loop = (abs((int(camera_pos_z)+38*40/2)/(38*40))\3)						;
	if(camera_pos_z+38*40/2 < 0) : road_loop=2-road_loop							;
																					;
	if(road_loop!=road_loop2){														;
		if(camera_pos_z >= camera_pos_z2) : addpos ROAD.road_loop2,0,0, 38*40*3		;
		if(camera_pos_z <  camera_pos_z2) : addpos ROAD.road_loop ,0,0,-38*40*3		;
	}																				;
	road_loop2 = road_loop															;


	;----歩道のループ----
	hodou_loop = (abs((int(camera_pos_z)+62/2)/62)\20)																				;
	if(camera_pos_z+62/2 < 0) : hodou_loop=19-hodou_loop																			;
																																	;
	if(hodou_loop!=hodou_loop2){																									;
		if(camera_pos_z >= camera_pos_z2) : addpos HODOU_RIGHT.hodou_loop2,0,0, 62*20 : addpos HODOU_LEFT.hodou_loop2,0,0, 62*20	;
		if(camera_pos_z <  camera_pos_z2) : addpos HODOU_RIGHT.hodou_loop ,0,0,-62*20 : addpos HODOU_LEFT.hodou_loop ,0,0,-62*20	;
	}																																;
	hodou_loop2 = hodou_loop
	
	;----木のループ----
	tree_loop = (abs((int(camera_pos_z)+25/2)/25)\50)																			;
	if(camera_pos_z+25/2 < 0) : tree_loop=49-tree_loop																			;
																																;
	if(tree_loop!=tree_loop2){																									;
		if(camera_pos_z >= camera_pos_z2) : addpos TREE_RIGHT.tree_loop2,0,0, 25*50 : addpos TREE_LEFT.tree_loop2,0,0, 25*50	;
		if(camera_pos_z <  camera_pos_z2) : addpos TREE_RIGHT.tree_loop ,0,0,-25*50 : addpos TREE_LEFT.tree_loop ,0,0,-25*50	;
	}																															;
	tree_loop2 = tree_loop
	
	;----先行車挙動----
	getpos Leading_CAR,CAR_pos_x,CAR_pos_y,CAR_pos_z
	if (camera_pos_z<20) {
	}
	else {
		;先行車の速度を決定
		if(v_set = 0){
			car_sokudo = double(lead_car_speed1) + (double(lead_car_speed2) - double(lead_car_speed1))/double(change_speed) * rnd(int(change_speed))
			v_set = 1
		}
	
		;時速→速度用変数
		if(car_sokudo ! car_sokudo2){
			car_speed =  0.2777778 * double(car_sokudo) * 0.015 * 6.0			;速度用変数を時速から算出
			car_sokudo2 = car_sokudo
		}
		;先行車の挙動を確定
		if(elasped_time >= time_set + adjust_range) : v_set = 0 : time_set = time_set + adjust_range
		if(CAR_pos_z-camera_pos_z)<LIM_SHAKAN_MAX and (CAR_pos_z-camera_pos_z)>LIM_SHAKAN_MIN : CAR_pos_z = CAR_pos_z2+car_speed
		if(CAR_pos_z-camera_pos_z)>LIM_SHAKAN_MAX : CAR_pos_z=camera_pos_z+LIM_SHAKAN_MAX-7			;305の理由は310に近すぎると挙動が…
		if(CAR_pos_z-camera_pos_z)<LIM_SHAKAN_MIN : CAR_pos_z=camera_pos_z+LIM_SHAKAN_MIN+7			;55の理由は50に近すぎると挙動が…
	}
	setpos Leading_CAR,0,0,CAR_pos_z
	CAR_pos_z2=CAR_pos_z
	
	if (CAR_pos_z-camera_pos_z)<=SHAKAN_MIN : color 255,0,0 : syakan=1
	if (CAR_pos_z-camera_pos_z)>=SHAKAN_MAX : color 0,0,255 : syakan=2
	if (CAR_pos_z-camera_pos_z)>SHAKAN_MIN && (CAR_pos_z-camera_pos_z)<SHAKAN_MAX : color 0,255,0 : syakan=0

	
	;----右車線の車----
	addpos R_CAR,0.0,0.0,R_CAR_S 							;右車線の車は110km/hで走行？
	getpos R_CAR,r_car_x,r_car_y,r_car_z					;右車線の車の座標を取得
	;見えなくなった車を後方へ設置
	if(r_car_z >= camera_pos_z+780){
		setpos R_CAR, -22, 0, camera_pos_z-10				;自身の座標から10座標後ろに設置
	}
	if(r_car_z < camera_pos_z-30){
		setpos R_CAR, -22, 0, camera_pos_z+500+20*rnd(4)	;自身の座標から500～650座標後ろに設置
	}
	
	if (r_car_z - camera_pos_z) <=0  &	(camera_pos_x <= -10) & (-34 <=camera_pos_x)	:jiko ="右車"
	;goto *exit		;右車線の車との接触		;強制終了	
	
	;----左車線の車----
	addpos L_CAR,0.0,0.0,L_CAR_S 							;左車線の車は100km/hで走行？
	getpos L_CAR,l_car_x,l_car_y,l_car_z					;左車線の車の座標を取得
	;見えなくなった車を後方へ設置
	if(l_car_z >= camera_pos_z+500){
		setpos L_CAR, 22, 0, camera_pos_z-10				;自身の座標から10座標後ろに設置
	}
	if(l_car_z < camera_pos_z-30){
		setpos L_CAR, 22, 0, camera_pos_z+500+20*rnd(4)		;自身の座標から500～650座標前に設置
	}
	
	if (l_car_z - camera_pos_z) <= 0 & (10 <= camera_pos_x)	& (camera_pos_x <= 34)	:jiko ="左車"
	;goto *exit			;左車線の車との接触		;強制終了	
	
return


//-------眠気判定--------------------------------------------------------------
*nemukehyouka
	;ボタンの状態をリセット
	if(15 < elasped_time)&&(elasped_time < 50)  : b_state = 0						;練習用
	if(time_m > 0)&&(0 < time_s)&&(time_s < 50) : b_state = 0						;本番用
	
	;buttonが押されたか判定
	if (elasped_time > 5) && (elasped_time < 15) && (data.9 = 1) : b_state = 1		;練習用
	if (time_s > 49) && (data.9 = 1) : b_state = 1								;buttonが押されたか判定
	
	if time_s =40 : nemuketi = 0
	if (b_state = 1) && (data.8 = 8)   : nemuketi = 1		;正常（覚醒）
	if (b_state = 1) && (data.8 = 32)  : nemuketi = 2		;少し眠い
	if (b_state = 1) && (data.8 = 128) : nemuketi = 3		;眠い・運転不能

	getkey shift,16 : if shift = 1 : nemuketi = 1	;shift
	getkey ctrl,17 	: if ctrl = 1  : nemuketi = 2	;ctrl
	getkey TAB,9    : if TAB = 1   : nemuketi = 3	;TAB
	
return


//--------フレーム描画為ののサブルーチン---------------------------------------
*alldraw

	hgdraw
	
	;----経過時間の取得----
	;起動時からの経過時間[ms]
	hggettime time,0		;hgini命令を通過してからの経過時間を 1ms 単位で取得	 ※ただし、上限は100000 msまで,それを超えると0 msから数え直す
	hggettime count,1		;上限である100000 msを超えた回数の取得
	time = count*100000+time-push_time	;現在の経過時間の算出
	;実験経過時間[s]&[min]
	if st_ex = 1 : elasped_time = (time - start_time)/1000				;総実験経過時間[sec]　=　(time_m)*60 ＋ (time_s)秒
	time_m = elasped_time/60							;実験経過時間[min単位]
	time_s = elasped_time\60							;実験経過時間[sec単位]
	
	;----カウントダウン----
	;200座標を過ぎたら10カウントしたら実験開始
	if (camera_pos_z > 200) && (cnt_n = 0){
		cnt_n = 15							;カウント回数=10
		sp_time = time						;スタート地点（z=200）を過ぎた時間
	}
	pos sign_xpos, sign_ypos : gmode 3,264,181,255
	if (camera_pos_z > 200) && ((time - sp_time)/1000) = (cnt_n - 15) : hgrotate sec_ago15,0,0,0, sign_xsize, sign_ysize	;⑩
	if (camera_pos_z > 200) && ((time - sp_time)/1000) = (cnt_n - 3) : hgrotate sec_ago3,0,0,0, sign_xsize, sign_ysize		;③
	if (camera_pos_z > 200) && ((time - sp_time)/1000) = (cnt_n - 2) : hgrotate sec_ago2,0,0,0, sign_xsize, sign_ysize		;②
	if (camera_pos_z > 200) &&  ((time - sp_time)/1000) = (cnt_n - 1) : hgrotate sec_ago1,0,0,0, sign_xsize, sign_ysize		;①
	if (camera_pos_z > 200) && ((time - sp_time)/1000) = cnt_n{
		hgrotate ready_go,0,0,0, sign_xsize, sign_ysize																		;Go!	
		if st_ex = 0 : start_time = time : st_ex = 1
	}
	
	;----眠気評価指標表示----
	;「眠気を評価してください」
	gmode 2,640,480,255 : pos sign_xpos, sign_ypos
	if (elasped_time>5)&&(elasped_time<15) : hgrotate moji,0,0,0, win_xsize, win_ysize		;開始５秒後に表示・練習用
	if (elasped_time>0)&&(time_s >= 50)    : hgrotate moji,0,0,0, win_xsize, win_ysize		;\:余り,表示時間,文字の設定(大きさ)	
	;「正常」「少し眠い」「眠い：運転不能」の文字
	gmode 2,640,480,255 : pos nemuke_xpos, nemuke_ypos
	;練習用
	if (nemuketi=1) && (elasped_time>5) && (elasped_time<15) : hgrotate kakusei,0,0,0, nemuke_xsize, nemuke_ysize		;正常
	if (nemuketi=2) && (elasped_time>5) && (elasped_time<15) : hgrotate sukosinemui,0,0,0, nemuke_xsize, nemuke_ysize	;少し眠い
	if (nemuketi=3) && (elasped_time>5) && (elasped_time<15) : hgrotate kanarinemui,0,0,0, nemuke_xsize, nemuke_ysize	;眠い：運転不能
	;本番用
	if (nemuketi=1) && (time_s > 50) : hgrotate kakusei,0,0,0, nemuke_xsize, nemuke_ysize					;正常
	if (nemuketi=1) && (time_s < 5)  : hgrotate kakusei,0,0,0, nemuke_xsize, nemuke_ysize					;正常
	if (nemuketi=2) && (time_s > 50)  : hgrotate sukosinemui,0,0,0, nemuke_xsize, nemuke_ysize				;少し眠い
	if (nemuketi=2) && (time_s < 5) : hgrotate sukosinemui,0,0,0, nemuke_xsize, nemuke_ysize				;少し眠い
	if (nemuketi=3) && (time_s > 50) : hgrotate kanarinemui,0,0,0, nemuke_xsize, nemuke_ysize				;眠い：運転不能
	if (nemuketi=3) && (time_s < 5) : hgrotate kanarinemui,0,0,0, nemuke_xsize, nemuke_ysize				;眠い：運転不能
	
	;----車間距離判定----
	gmode 3,100,100,75
	hgrect BLUE_FRAME_CENTER_X,BLUE_FRAME_CENTER_Y-BLUE_FRAME_HEIGHT/2-10,0,BLUE_FRAME_WIDTH+BLUE_FRAME_THICKNESS,BLUE_FRAME_THICKNESS	;上
	hgrect BLUE_FRAME_CENTER_X,BLUE_FRAME_CENTER_Y+BLUE_FRAME_HEIGHT/2-10,0,BLUE_FRAME_WIDTH+BLUE_FRAME_THICKNESS,BLUE_FRAME_THICKNESS	;下
	hgrect BLUE_FRAME_CENTER_X-BLUE_FRAME_WIDTH/2,BLUE_FRAME_CENTER_Y-10,0,BLUE_FRAME_THICKNESS,BLUE_FRAME_HEIGHT						;左
	hgrect BLUE_FRAME_CENTER_X+BLUE_FRAME_WIDTH/2,BLUE_FRAME_CENTER_Y-10,0,BLUE_FRAME_THICKNESS,BLUE_FRAME_HEIGHT
	
	;------確認用フィードバック----------------
	fprt "jisoku: "+int(jisoku2)+"km/h",8,70								;自車の時速[km/h]
	;fprt "elapsed_time:"+elasped_time,8,90									;実験開始からの経過時間[sec]
	fprt "nemuketi:"+nemuketi,8,150											;眠気の状態
	fprt "time:"+time_m+" min "+time_s+" sec",8,190							;経過時間を分・秒で表示
	;fprt "s_time:"+s_time,8,150											;サンプリング回数
	;fprt "camera_ang_y: "+camera_ang_y,8,190								;車の傾き(方向･角度）
	;fprt "camera_pos_x: "+camera_pos_x,8,210								;車の走行距離(座標）
	;fprt "camera_pos_y: "+camera_pos_x,8,230								;車の走行距離(座標）	
	;fprt "camera_pos_z: "+camera_pos_z,8,250								;車の走行距離(座標）	
	;fprt "car_speed: "+car_speed,8,230										;先行車の１フレームでの座標移動距離
	fprt "lead_car_speed: "+car_sokudo+"km/h",8,110							;先行車の時速[km/h]
	;fprt "time_set: "+time_set+"",8,270									;現在の先行車の時速をセットした変更した時間
	;fprt "syakan: "+syakan,8,290											;車間距離の状態「指定範囲内かどうか」
	fprt "syakannkyori: "+(CAR_pos_z-camera_pos_z)+"",8,230					;車間距離
	;fprt "CAR_pos_z-camera_pos_z: "+(CAR_pos_z-camera_pos_z)+"",8,170		;先行車との車間距離
	;fprt "CAR_pos_z: "+CAR_pos_z,8,270										;先行車の位置
	
	
	frame++				;フレーム回数カウント用変数
	
	hgsync 14	;時間待ち（処理が速くなり過ぎないように）
	
return



//*************************
*abc
	notesel save_data
	noteadd ""+s_time+","+time+","+elasped_time+","+camera_pos_z+","+camera_pos_x+","+nemuketi+","+b_state+","+syakan+","+(CAR_pos_z - camera_pos_z)+","+car_sokudo+","+pedal+","+pedal_per+","+jiko ,s_time,1
	s_time++
return

//--------終了前の操作----------------------------------------------------------
*exit
	notesel save_data
	noteadd "総サンプリング回数,時間[ms],実験時間[s],走行距離,トラッキング,眠気,スイッチの状態,車間の状態,車間距離,先行車の時速[km/h],ペダルの状態,ペダルの踏み込み具合[%],事故"
	dialog "*",17,"テキストファイル"	;保存用のダイアログを別ウインドウで表示
	if stat=1 : notesave refstr+".txt"	;ファイル名を記載した場合、その名前のテキストファイル作成

	end		;onexitで割り込み処理をする場合、endを書かなければウインドウを閉じれなくなるので注意

